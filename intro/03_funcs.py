# Функції
def func1() :
    print("Hello  from function 1")


x = 10  # глобальна змінна
def get_x() :              # традиції іменування - snake_case
    return x


def set_x(value) :          # На відміну від очікування,           
    x = value               # дана інструкція звертається не до глобальної
    print("new value", x)   # змінної, а створює локальну
# Принцип розіменування літералу (пошуку значення за іменем елемента)
# 1. Здійснюється пошук у локальній області (наприклад, у тілі ф-ції)
# 2. Продовжується пошук у параметричній області (серед параметів ф-ції)
# 3. Продовжується пошук у лексикографічному околі (capture, closure)
# 4. Завершується пошук у глобальній області (або більш глобальній)
# Чому get_x звертається до глобальної змінної, а set_x - до локальної
#  якщо синтаксис звернення однаковий?
# Відмінність у суті питання: get_x питає "чи можна читати", а 
#  set_x - "чи можна писати (створити)"

def set_g(value) :   # Якщо потрібно звертатись саме до          
    global x         # глобальної змінної, то до неї додають
    x = value        # оператор global


def get_x(addon=0) : # чи можливе перевантаження ф-цій?
    return(x +       # Ні, повторне оголошення не створюючи помилок
           addon)    # замінює собою попереднє оголошення


def show(x:int=1, y:int=2, w:int=3) -> None :
    '''Документуючий коментар: відсутність перевантаження компенсується
    можливістю значень за замовчанням та зверненням до них 
    
    a) за іменем на кшталт show(y=5)
    
    б) за позицією show(6) 
    
    в) комбіновано show(8, w=1)'''
    
    print(x, y, w)


# Чи можлива рекурсія?
def fact(n:int) -> int :
    return 1 if n < 2 else n * fact(n-1)    


def main() :
    func1()
    print(get_x())   # 10 - функції мають доступ до глобальних змінних
    set_x(20)        # new value 20
    print(get_x())   # 10
    set_g(30)        # 
    print(get_x(1))  # 31
    show()           # всі параметри за замовчанням 
    show(6)          # позиційне зв'язування - з першим параметром
    show(y=7)        # іменоване зв'язування - з параметром "y"
    show(8, w="A")   # комбіноване - один за позицією, другий - за іменем
                     # відхилення від зазначених у ф-ції типів не дає помилок
    print(fact(5))


if __name__ == '__main__' :
    main()


'''
У Python діє модульна система, файли можуть підключатись до інших 
файлів оператором import.
Підключення файла супроводжується його виконанням, при цьому 
у виконавця формується ім'я для даного модулю, яке зберігається
у спеціальній змінній __name__. Для головного модуля (стартового
файлу) це ім'я має значення '__main__'
'''    
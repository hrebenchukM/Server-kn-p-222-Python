# Python — інтерпретована (REPL) мова програмування 4-го покоління
# Підтримує багато парадигм, основна — функціональна

x = 10
# Змінні — підтримуються, декларація не потрібна
print(x, type(x))  # 10 <class 'int'>

x = 1 + 2j
# Математична орієнтація — підтримка комплексних чисел
print(x, type(x))  # (1+2j) <class 'complex'>

# Тип даних змінюється при присвоєнні, лише ім'я залишається без змін
s = "string"
print(s, type(s))  # string <class 'str'>

# print(s + x)  # can only concatenate str (not "complex") to str
# print(x + s)  # unsupported operand type(s) for +: 'complex' and 'str'

# Типізація сувора? (не плутати з динамічною/статичною)
# Сувора типізація забороняє операції з різними типами (немає неявних перетворень типів)
y = 20

# print(x + y)  # (21+2j) <class 'complex'>
# Типізація не сувора, різні типи можуть комбінуватись (з винятками)

print(2 ** 1000)  
# Формального обмеження на цілі числа немає

print(2.0 ** 1000)
# 1.0715086071862653e+301 — для дробових чисел класичне 64-бітне подання

print(3 / 2)
# 1.5 — зміна типу: ціле / ціле → дробове

print(3 // 2)
# 1 — цілочисельне ділення

# # # # # # # # 
s = "str" \
"ing"                     # \ — розрив команди на декілька рядків

# Для багаторядкових значень використовується окремий синтаксис
s = """line1
line 2
line 3"""

s = f"x = {x}"             # x = (1+2j) — інтерполяція рядків
print(s)

# Типи даних, специфічні для функціональних мов
а = (1, 2, 3)              
# кортеж (tuple) послідовність об'єктів(без обмеження змін)
print(а, type(а))          
# (1, 2, 3) <class 'tuple'>

# перелік (list) – послідовність з можливістю змін
b = [1, 2, 3]
b[1] = 'a'
print(b, type(b))  
# [1, 'a', 3] <class 'list'>

# множина (set) – перелік елементів без повторення
c = {1, 2, 3}
print(c, type(c))  
# {1, 2, 3} <class 'set'>

# словник (dict) – структура даних "ключ: значення"
d = {
    'k1': 'v1',
    'k2': 'v2'
}
print(d, type(d))  
# {'k1': 'v1', 'k2': 'v2'} <class 'dict'>

# Зчеплення з кортежем
print('int: %s, str: "%s", float: %.2f' % а )
print(3 % 2)  # Роль оператора залежить від операндів: тут % — залишок, вище — зчеплювач

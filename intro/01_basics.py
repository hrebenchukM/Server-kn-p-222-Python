# Python - інтерпретована (REPL) мова програмування 4 покоління
# підтримка багатьох парадигм, основна - функціональна
x = 10             # змінні - підтримуються, декларації не потрібно
print(x, type(x))  # 10 <class 'int'>
x = 1 + 2j         # мат.орієнтація - підтримка комплексних чисел
print(x, type(x))  # (1+2j) <class 'complex'>
# тип даних змінюється при присвоєнні лишаючи ім'я без змін
s = "string"
print(s, type(s))  # string <class 'str'>
# print(s + x)     # can only concatenate str (not "complex") to str
# print(x + s)     # TypeError: unsupported operand type(s) for +: 'complex' and 'str'
# ? типізація сувора ? (не плутати з динамічною/статичною)
# сувора типізація забороняє операції з різними типами (не має неявних перетворень типів)
y = 20
print(x + y,        # (21+2j) <class 'complex'>
      type(x + y))  # типізація не сувора, різні типу можуть комбінуватись (з винятками)
print(2 ** 1000)    # формального обмеження на цілі числа немає
print(2.0 ** 1000)  # 1.0715086071862673e+301 -- для дробових чисел - класичне 64 бітне подання
print(3 / 2)        # 1.5 - зміна типу - ціле/ціле -> дробове
print(3 // 2)       # 1 -- цілочисельне ділення

s = "str" \
"ing"               # \ - розрив команди на декілька рядків
# для багаторядкових значень використовується окремий синтаксис
s = """line1 
line 2
line 3"""

s = f"x = {x}"      # x = (1+2j) -- інтерполяція рядків
print(s)

# Типи даних, специфічні для функціональних мов
a = (1, 2, 3)          # кортеж (tuple) - послідовність об'єктів (без можливості змін)
print(a, type(a))      # (1, 2, 3) <class 'tuple'>
a = (1, "Hello", 2.5)  # однаковість типів - непотрібна
print(a, type(a)) 

b = [1, 2, 3]          # перелік (list) - послідовність з можливістю змін
b[1] = 'a'
print(b, type(b))      # [1, 'a', 3] <class 'list'>

c = {1, 2, 3}          # множина (set) - перелік елементів без повторення
print(c, type(c))      # {1, 2, 3} <class 'set'>

d = {
    'k1': "v1",
    'k2': 'v2'
}
print(d, type(d))      # {'k1': 'v1', 'k2': 'v2'} <class 'dict'>

# Зчеплення з кортежем
print("int: %s, str: '%s', float: %.2f" % a)
print(3 % 2)           # ! роль оператора залежить від операндів: тут % - залишок, вище - зчеплювач